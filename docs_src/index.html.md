---
title: Flatbuffers

language_tabs: # must be one of https://git.io/vQNgJ
  - cpp
  - java
  - csharp
  - python

toc_footers:
  - <a href='https://github.com/slatedocs/slate'>Documentation Powered by Slate</a>

search: true

code_clipboard: true
---

# Introduction

Flatbuffers

# Programmer's Guide

# Tutorial

## Writing the Monsters FlatBuffer Schema

> Example IDL file for our monster's schema:

```
  namespace MyGame.Sample;

  enum Color:byte { Red = 0, Green, Blue = 2 }

  union Equipment { Weapon } // Optionally add more tables.

  struct Vec3 {
    x:float;
    y:float;
    z:float;
  }

  table Monster {
    pos:Vec3; // Struct.
    mana:short = 150;
    hp:short = 100;
    name:string;
    friendly:bool = false (deprecated);
    inventory:[ubyte];  // Vector of scalars.
    color:Color = Blue; // Enum.
    weapons:[Weapon];   // Vector of tables.
    equipped:Equipment; // Union.
    path:[Vec3];        // Vector of structs.
  }

  table Weapon {
    name:string;
    damage:short;
  }

  root_type Monster;
```
To start working with FlatBuffers, you first need to create a `schema` file,
which defines the format for each data structure you wish to serialize. Here is
the `schema` that defines the template for our monsters

As you can see, the syntax for the `schema`
[Interface Definition Language (IDL)](https://en.wikipedia.org/wiki/Interface_description_language)
is similar to those of the C family of languages, and other IDL languages. Let's
examine each part of this `schema` to determine what it does.

The `schema` starts with a `namespace` declaration. This determines the
corresponding package/namespace for the generated code. In our example, we have
the `Sample` namespace inside of the `MyGame` namespace.

Next, we have an `enum` definition. In this example, we have an `enum` of type
`byte`, named `Color`. We have three values in this `enum`: `Red`, `Green`, and
`Blue`. We specify `Red = 0` and `Blue = 2`, but we do not specify an explicit
value for `Green`. Since the behavior of an `enum` is to increment if
unspecified, `Green` will receive the implicit value of `1`.

Following the `enum` is a `union`. The `union` in this example is not very
useful, as it only contains the one `table` (named `Weapon`). If we had created
multiple tables that we would want the `union` to be able to reference, we
could add more elements to the `union Equipment`.

After the `union` comes a `struct Vec3`, which represents a floating point
vector with `3` dimensions. We use a `struct` here, over a `table`, because
`struct`s are ideal for data structures that will not change, since they use
less memory and have faster lookup.

The `Monster` table is the main object in our FlatBuffer. This will be used as
the template to store our `orc` monster. We specify some default values for
fields, such as `mana:short = 150`. If unspecified, scalar fields (like `int`,
`uint`, or `float`) will be given a default of `0` while strings and tables will
be given a default of `null`. Another thing to note is the line `friendly:bool =
false (deprecated);`. Since you cannot delete fields from a `table` (to support
backwards compatability), you can set fields as `deprecated`, which will prevent
the generation of accessors for this field in the generated code. Be careful
when using `deprecated`, however, as it may break legacy code that used this
accessor.

The `Weapon` table is a sub-table used within our FlatBuffer. It is
used twice: once within the `Monster` table and once within the `Equipment`
union. For our `Monster`, it is used to populate a `vector of tables` via the
`weapons` field within our `Monster`. It is also the only table referenced by
the `Equipment` union.

The last part of the `schema` is the `root_type`. The root type declares what
will be the root table for the serialized data. In our case, the root type is
our `Monster` table.

The scalar types can also use alias type names such as `int16` instead
of `short` and `float32` instead of `float`. Thus we could also write
the `Weapon` table as:

## Reading and Writing Monster FlatBuffers

### Importing dependencies

```cpp
  #include "monster_generated.h" // This was generated by `flatc`.

  using namespace MyGame::Sample; // Specified in the schema.
```

```java
  import MyGame.Sample.*; //The `flatc` generated files. (Monster, Vec3, etc.)

  import com.google.flatbuffers.FlatBufferBuilder;
```

```csharp
  using FlatBuffers;
  using MyGame.Sample; // The `flatc` generated files. (Monster, Vec3, etc.)
```

```python
  import flatbuffers

  # Generated by `flatc`.
  import MyGame.Sample.Color
  import MyGame.Sample.Equipment
  import MyGame.Sample.Monster
  import MyGame.Sample.Vec3
  import MyGame.Sample.Weapon
```

Now that we have compiled the schema for our programming language, we can
start creating some monsters and serializing/deserializing them from
FlatBuffers.

### Initialize the flatbuffer builder

```cpp
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  flatbuffers::FlatBufferBuilder builder(1024);
```

```java
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  FlatBufferBuilder builder = new FlatBufferBuilder(1024);
```

```csharp
  // Create a `FlatBufferBuilder`, which will be used to create our
  // monsters' FlatBuffers.
  var builder = new FlatBufferBuilder(1024);
```

```python
  # Create a `FlatBufferBuilder`, which will be used to create our
  # monsters' FlatBuffers.
  builder = flatbuffers.Builder(1024)
```

The first step is to import/include the library, generated files, etc.

Now we are ready to start building some buffers. In order to start, we need
to create an instance of the `FlatBufferBuilder`, which will contain the buffer
as it grows. You can pass an initial size of the buffer (here 1024 bytes),
which will grow automatically if needed:

# Languages

Flatbuffers supports a variety of languages. The follow sections highlight 
specifics of the languages.

<!-- Using this instead of #C++ as that doesn't produce the correct anchor-->
<h2 id="cpp">C++</h2>

```cpp
  #include "flatbuffers/flatbuffers.h"
  #include "monster_test_generate.h"
  #include <iostream> // C++ header file for printing
  #include <fstream> // C++ header file for file access
  
  
  std::ifstream infile;
  infile.open("monsterdata_test.mon", std::ios::binary | std::ios::in);
  infile.seekg(0,std::ios::end);
  int length = infile.tellg();
  infile.seekg(0,std::ios::beg);
  char *data = new char[length];
  infile.read(data, length);
  infile.close();
  
  auto monster = GetMonster(data);
```

Note: See [Tutorial](#tutorial) for a more in-depth example of how to use FlatBuffers in C++.

FlatBuffers supports both reading and writing FlatBuffers in C++.

# FILLER

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)

This is filler text due to bug [#1440](https://github.com/slatedocs/slate/issues/1440)